"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clearCache = exports.runPathRecipeSync = exports.runPathRecipe = void 0;
const child_process_1 = require("child_process");
// We keep two separate caches, but propagate them both at the same time.
// The reason for keeping two, is the fact that we want to cache unresolved
// Promises too, to avoid triggering async runPathRecipe multiple times.
const _runPathRecipeCache = {};
const _runPathRecipeSyncCache = {};
function _runPathRecipe(recipe) {
    return new Promise((resolve, reject) => {
        (0, child_process_1.execFile)("brazil-path", [recipe], { maxBuffer: 1024 * 1024 }, (err, stdout) => {
            if (err)
                return reject(err);
            resolve(stdout.trim());
        });
    });
}
async function runPathRecipe(recipe, opts) {
    if (isMemoizationEnabled(opts?.memoize)) {
        const cacheKey = pathRecipeCacheKeyResolver(recipe);
        const asyncRecipePromise = (_runPathRecipeCache[cacheKey] ?? (_runPathRecipeCache[cacheKey] = _runPathRecipe(recipe)));
        // Once resolved, propagating sync cache as well
        return (_runPathRecipeSyncCache[cacheKey] ?? (_runPathRecipeSyncCache[cacheKey] = await asyncRecipePromise));
    }
    return _runPathRecipe(recipe);
}
exports.runPathRecipe = runPathRecipe;
function _runPathRecipeSync(recipe) {
    return (0, child_process_1.execFileSync)("brazil-path", [recipe], {
        maxBuffer: 1024 * 1024,
        encoding: "utf8",
    }).trim();
}
function runPathRecipeSync(recipe, opts) {
    if (isMemoizationEnabled(opts?.memoize)) {
        const cacheKey = pathRecipeCacheKeyResolver(recipe);
        const syncRecipeResult = (_runPathRecipeSyncCache[cacheKey] ?? (_runPathRecipeSyncCache[cacheKey] = _runPathRecipeSync(recipe)));
        // Propagating async cache as well since we have the result already
        _runPathRecipeCache[cacheKey] ?? (_runPathRecipeCache[cacheKey] = Promise.resolve(syncRecipeResult));
        return syncRecipeResult;
    }
    return _runPathRecipeSync(recipe);
}
exports.runPathRecipeSync = runPathRecipeSync;
/**
 * Returns user-provided memoization setting, or true if not provided.
 * It's possible to opt-out from default memoization by setting
 * BRAZIL_PATH_MEMOIZATION_DISABLED to 'true' or '1'.
 *
 * @default true
 */
function isMemoizationEnabled(memoize) {
    if (memoize != null)
        return memoize;
    return (process.env.BRAZIL_PATH_MEMOIZATION_DISABLED !== "true" &&
        process.env.BRAZIL_PATH_MEMOIZATION_DISABLED !== "1");
}
/**
 * Running brazil-path from different working directories will have
 * a different result, hence memoization should be scoped to cwd.
 */
function pathRecipeCacheKeyResolver(recipe) {
    return `${process.cwd()}:${recipe}`;
}
/**
 * Used for unit testing purposes only.
 * Do not export to customers.
 */
function clearCache() {
    Object.keys(_runPathRecipeCache).forEach((key) => delete _runPathRecipeCache[key]);
    Object.keys(_runPathRecipeSyncCache).forEach((key) => delete _runPathRecipeSyncCache[key]);
}
exports.clearCache = clearCache;
